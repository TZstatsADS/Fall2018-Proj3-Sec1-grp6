load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
superResolution <- function(LR_dir, HR_dir, modelList){
### Construct high-resolution images from low-resolution images with trained predictor
### Input: a path for low-resolution images + a path for high-resolution images
###        + a list for predictors
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
### read LR/HR image pairs
for(i in 1:n_files){
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
### step 1. sample n_points from imgLR
dimLR <- dim(imgLR)
pixels = 1:length(dimLR[1] * dimLR[2])
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_col <- (pixels - 1)%/%dimLR[1] + 1
### step 2. for each sampled point in imgLR
### step 2.1. save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
n_points <- dim(imgLR)[1] * dim(imgLR)[2]
for(j in 1:3){
pad <- cbind(0, imgLR[,,j], 0)
pad <- rbind(0, pad, 0)
featMat[(i-1)*n_points + 1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
featMat[(i-1)*n_points + 1:n_points, 2, j] <- pad[cbind(pixels_row, pixels_col + 1)]
featMat[(i-1)*n_points + 1:n_points, 3, j] <- pad[cbind(pixels_row, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 4, j] <- pad[cbind(pixels_row +1, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 5, j] <- pad[cbind(pixels_row +2, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 6, j] <- pad[cbind(pixels_row+2, pixels_col+1)]
featMat[(i-1)*n_points + 1:n_points, 7, j] <- pad[cbind(pixels_row+2, pixels_col)]
featMat[(i-1)*n_points + 1:n_points, 8, j] <- pad[cbind(pixels_row+1, pixels_col)]
}
### step 2. apply the modelList over featMat
predMat <- test(modelList, featMat)
print(predMat)
print(dim(predMat))
### step 3. recover high-resolution from predMat and save in HR_dir
writeImage(predMat, file = paste(HR_dir, i, ".jpeg", sep = ""))
}
}
#source("../lib/superResolution.R")
test_dir <- "../data/test_sample/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
train_LR_dir
test <- function(modelList, dat_test){
### Fit the classfication model with testing data
### Input:
###  - the fitted classification model list using training data
###  - processed features from testing images
### Output: training model specification
### load libraries
library("gbm")
predArr <- array(NA, c(dim(dat_test)[1], 4, 3))
for (i in 1:12){
fit_train <- modelList[[i]]
### calculate column and channel
c1 <- (i-1) %% 4 + 1
c2 <- (i-c1) %/% 4 + 1
featMat <- dat_test[, , c2]
### make predictions
predArr[, c1, c2] <- predict(fit_train$fit, newdata=featMat,
n.trees=fit_train$iter, type="response")
}
return(list( numericpred = as.numeric(predArr), arraypred = predArr))
}
superResolution <- function(LR_dir, HR_dir, modelList){
### Construct high-resolution images from low-resolution images with trained predictor
### Input: a path for low-resolution images + a path for high-resolution images
###        + a list for predictors
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
### read LR/HR image pairs
for(i in 1:n_files){
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
### step 1. sample n_points from imgLR
dimLR <- dim(imgLR)
pixels = 1:length(dimLR[1] * dimLR[2])
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_col <- (pixels - 1)%/%dimLR[1] + 1
### step 2. for each sampled point in imgLR
### step 2.1. save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
n_points <- dim(imgLR)[1] * dim(imgLR)[2]
for(j in 1:3){
pad <- cbind(0, imgLR[,,j], 0)
pad <- rbind(0, pad, 0)
featMat[(i-1)*n_points + 1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
featMat[(i-1)*n_points + 1:n_points, 2, j] <- pad[cbind(pixels_row, pixels_col + 1)]
featMat[(i-1)*n_points + 1:n_points, 3, j] <- pad[cbind(pixels_row, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 4, j] <- pad[cbind(pixels_row +1, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 5, j] <- pad[cbind(pixels_row +2, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 6, j] <- pad[cbind(pixels_row+2, pixels_col+1)]
featMat[(i-1)*n_points + 1:n_points, 7, j] <- pad[cbind(pixels_row+2, pixels_col)]
featMat[(i-1)*n_points + 1:n_points, 8, j] <- pad[cbind(pixels_row+1, pixels_col)]
}
### step 2. apply the modelList over featMat
predMat <- test(modelList, featMat)$arraypred
### step 3. recover high-resolution from predMat and save in HR_dir
writeImage(predMat, file = paste(HR_dir, i, ".jpeg", sep = ""))
}
}
#source("../lib/superResolution.R")
test_dir <- "../data/test_sample/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
seq(100,1)
seq(1,100)
superResolution <- function(LR_dir, HR_dir, modelList){
### Construct high-resolution images from low-resolution images with trained predictor
### Input: a path for low-resolution images + a path for high-resolution images
###        + a list for predictors
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
### read LR/HR image pairs
for(i in 1:n_files){
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
### step 1. sample n_points from imgLR
dimLR <- dim(imgLR)
pixels = seq(1,dimLR[1] * dimLR[2])
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_col <- (pixels - 1)%/%dimLR[1] + 1
### step 2. for each sampled point in imgLR
### step 2.1. save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
n_points <- dim(imgLR)[1] * dim(imgLR)[2]
for(j in 1:3){
pad <- cbind(0, imgLR[,,j], 0)
pad <- rbind(0, pad, 0)
featMat[(i-1)*n_points + 1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
featMat[(i-1)*n_points + 1:n_points, 2, j] <- pad[cbind(pixels_row, pixels_col + 1)]
featMat[(i-1)*n_points + 1:n_points, 3, j] <- pad[cbind(pixels_row, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 4, j] <- pad[cbind(pixels_row +1, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 5, j] <- pad[cbind(pixels_row +2, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 6, j] <- pad[cbind(pixels_row+2, pixels_col+1)]
featMat[(i-1)*n_points + 1:n_points, 7, j] <- pad[cbind(pixels_row+2, pixels_col)]
featMat[(i-1)*n_points + 1:n_points, 8, j] <- pad[cbind(pixels_row+1, pixels_col)]
}
### step 2. apply the modelList over featMat
predMat <- test(modelList, featMat)$arraypred
### step 3. recover high-resolution from predMat and save in HR_dir
writeImage(predMat, file = paste(HR_dir, i, ".jpeg", sep = ""))
}
}
#source("../lib/superResolution.R")
test_dir <- "../data/test_sample/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
n_points
LR_dir=test_LR_dir
HR_dir=test_HR_dir
modelList=fit_train
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
### read LR/HR image pairs
for(i in 1:n_files){
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
### step 1. sample n_points from imgLR
dimLR <- dim(imgLR)
pixels = seq(1,dimLR[1] * dimLR[2])
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_col <- (pixels - 1)%/%dimLR[1] + 1
### step 2. for each sampled point in imgLR
### step 2.1. save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
n_points <- dim(imgLR)[1] * dim(imgLR)[2]
for(j in 1:3){
pad <- cbind(0, imgLR[,,j], 0)
pad <- rbind(0, pad, 0)
featMat[(i-1)*n_points + 1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
featMat[(i-1)*n_points + 1:n_points, 2, j] <- pad[cbind(pixels_row, pixels_col + 1)]
featMat[(i-1)*n_points + 1:n_points, 3, j] <- pad[cbind(pixels_row, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 4, j] <- pad[cbind(pixels_row +1, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 5, j] <- pad[cbind(pixels_row +2, pixels_col+2)]
featMat[(i-1)*n_points + 1:n_points, 6, j] <- pad[cbind(pixels_row+2, pixels_col+1)]
featMat[(i-1)*n_points + 1:n_points, 7, j] <- pad[cbind(pixels_row+2, pixels_col)]
featMat[(i-1)*n_points + 1:n_points, 8, j] <- pad[cbind(pixels_row+1, pixels_col)]
}
### step 2. apply the modelList over featMat
predMat <- test(modelList, featMat)$arraypred
### step 3. recover high-resolution from predMat and save in HR_dir
writeImage(predMat, file = paste(HR_dir, i, ".jpeg", sep = ""))
}
n_points
dim(imgLR)[1]
pixels_row
pixels_col
cbind(pixels_row, pixels_col)
pixels
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_row
select = sample(dimLR[1] * dimLR[2], n_points)
select
n_points
select_row <- (select - 1)%%dimLR[1] + 1
select_row
select = sample(dimLR[1] * dimLR[2], 10)
select_row <- (select - 1)%%dimLR[1] + 1
select_row
dimLR[1]
dimLR[1]
select_col <- (select - 1)%/%dimLR[1] + 1
select_col
pixels = seq(1,dimLR[1] * dimLR[2])
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_col <- (pixels - 1)%/%dimLR[1] + 1
pixels_row
pixels_col
pixels_row
n_points <- dim(imgLR)[1] * dim(imgLR)[2]
n_points
featMat[(i-1)*n_points + 1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
(i-1)*n_points + 1:n_points
pad[cbind(pixels_row, pixels_col)]
dim(pad[cbind(pixels_row, pixels_col)])
pad[cbind(pixels_row, pixels_col)]
dim(pad)
dim(cbind(pixels_row, pixels_col))
length(pad[cbind(pixels_row, pixels_col)])
featMat[(i-1)*n_points + 1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
(1-1)*n_points + 1:n_points
length((1-1)*n_points + 1:n_points)
dim(pad[cbind(pixels_row, pixels_col)])
length(pad[cbind(pixels_row, pixels_col)])
featMat[(i-1)*n_points + 1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
superResolution <- function(LR_dir, HR_dir, modelList){
### Construct high-resolution images from low-resolution images with trained predictor
### Input: a path for low-resolution images + a path for high-resolution images
###        + a list for predictors
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
### read LR/HR image pairs
for(i in 1:n_files){
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
### step 1. sample n_points from imgLR
dimLR <- dim(imgLR)
pixels = seq(1,dimLR[1] * dimLR[2])
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_col <- (pixels - 1)%/%dimLR[1] + 1
### step 2. for each sampled point in imgLR
### step 2.1. save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
n_points <- dim(imgLR)[1] * dim(imgLR)[2]
for(j in 1:3){
pad <- cbind(0, imgLR[,,j], 0)
pad <- rbind(0, pad, 0)
featMat[1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
featMat[1:n_points, 2, j] <- pad[cbind(pixels_row, pixels_col + 1)]
featMat[1:n_points, 3, j] <- pad[cbind(pixels_row, pixels_col+2)]
featMat[1:n_points, 4, j] <- pad[cbind(pixels_row +1, pixels_col+2)]
featMat[1:n_points, 5, j] <- pad[cbind(pixels_row +2, pixels_col+2)]
featMat[1:n_points, 6, j] <- pad[cbind(pixels_row+2, pixels_col+1)]
featMat[1:n_points, 7, j] <- pad[cbind(pixels_row+2, pixels_col)]
featMat[1:n_points, 8, j] <- pad[cbind(pixels_row+1, pixels_col)]
}
### step 2. apply the modelList over featMat
predMat <- test(modelList, featMat)$arraypred
### step 3. recover high-resolution from predMat and save in HR_dir
writeImage(predMat, file = paste(HR_dir, i, ".jpg", sep = ""))
}
}
#source("../lib/superResolution.R")
test_dir <- "../data/test_sample/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(LR_dir=test_LR_dir, HR_dir=test_HR_dir, modelList=fit_train))
}
#source("../lib/superResolution.R")
test_dir <- "../data/test_sample/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(LR_dir=test_LR_dir, HR_dir=test_HR_dir, modelList=fit_train))
}
predMat
dim(predMat)
predMat
dimLR
predMat/dimLR[2]
dim(predMat)
dim(predMat)[1]/(dimLR[2]*2)
dimLR
dim(predMat)[1]/(dimLR[2])
dim(predMat)[1]/(dimLR[1])
dimLR
dimLR[1]
dim(predMat)[1]
dim(predMat)[1]/(dimLR[1])
superResolution <- function(LR_dir, HR_dir, modelList){
### Construct high-resolution images from low-resolution images with trained predictor
### Input: a path for low-resolution images + a path for high-resolution images
###        + a list for predictors
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
### read LR/HR image pairs
for(i in 1:1){
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
### step 1. sample n_points from imgLR
dimLR <- dim(imgLR)
pixels = seq(1,dimLR[1] * dimLR[2])
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_col <- (pixels - 1)%/%dimLR[1] + 1
### step 2. for each sampled point in imgLR
### step 2.1. save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
n_points <- dim(imgLR)[1] * dim(imgLR)[2]
for(j in 1:3){
pad <- cbind(0, imgLR[,,j], 0)
pad <- rbind(0, pad, 0)
featMat[1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
featMat[1:n_points, 2, j] <- pad[cbind(pixels_row, pixels_col + 1)]
featMat[1:n_points, 3, j] <- pad[cbind(pixels_row, pixels_col+2)]
featMat[1:n_points, 4, j] <- pad[cbind(pixels_row +1, pixels_col+2)]
featMat[1:n_points, 5, j] <- pad[cbind(pixels_row +2, pixels_col+2)]
featMat[1:n_points, 6, j] <- pad[cbind(pixels_row+2, pixels_col+1)]
featMat[1:n_points, 7, j] <- pad[cbind(pixels_row+2, pixels_col)]
featMat[1:n_points, 8, j] <- pad[cbind(pixels_row+1, pixels_col)]
}
### step 2. apply the modelList over featMat
predMat <- test(modelList, featMat)$arraypred
### step 3. recover high-resolution from predMat and save in HR_dir
imagearray <- array(NA, c((dim(imgLR)[1]*2) * (dim(imgLR)[2]*2), 8, 3))
for(k in 1:3){
imagearray[,,k] <-
}
writeImage(imagearray, file = paste(HR_dir, i, ".jpg", sep = ""))
}
}
superResolution <- function(LR_dir, HR_dir, modelList){
### Construct high-resolution images from low-resolution images with trained predictor
### Input: a path for low-resolution images + a path for high-resolution images
###        + a list for predictors
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
### read LR/HR image pairs
for(i in 1:1){
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
### step 1. sample n_points from imgLR
dimLR <- dim(imgLR)
pixels = seq(1,dimLR[1] * dimLR[2])
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_col <- (pixels - 1)%/%dimLR[1] + 1
### step 2. for each sampled point in imgLR
### step 2.1. save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
n_points <- dim(imgLR)[1] * dim(imgLR)[2]
for(j in 1:3){
pad <- cbind(0, imgLR[,,j], 0)
pad <- rbind(0, pad, 0)
featMat[1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
featMat[1:n_points, 2, j] <- pad[cbind(pixels_row, pixels_col + 1)]
featMat[1:n_points, 3, j] <- pad[cbind(pixels_row, pixels_col+2)]
featMat[1:n_points, 4, j] <- pad[cbind(pixels_row +1, pixels_col+2)]
featMat[1:n_points, 5, j] <- pad[cbind(pixels_row +2, pixels_col+2)]
featMat[1:n_points, 6, j] <- pad[cbind(pixels_row+2, pixels_col+1)]
featMat[1:n_points, 7, j] <- pad[cbind(pixels_row+2, pixels_col)]
featMat[1:n_points, 8, j] <- pad[cbind(pixels_row+1, pixels_col)]
}
### step 2. apply the modelList over featMat
predMat <- test(modelList, featMat)$arraypred
### step 3. recover high-resolution from predMat and save in HR_dir
#imagearray <- array(NA, c((dim(imgLR)[1]*2) * (dim(imgLR)[2]*2), 8, 3))
#for(k in 1:3){
#imagearray[,,k] <-
#}
writeImage(imagearray, file = paste(HR_dir, i, ".jpg", sep = ""))
}
}
#source("../lib/superResolution.R")
test_dir <- "../data/test_sample/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(LR_dir=test_LR_dir, HR_dir=test_HR_dir, modelList=fit_train))
}
superResolution <- function(LR_dir, HR_dir, modelList){
### Construct high-resolution images from low-resolution images with trained predictor
### Input: a path for low-resolution images + a path for high-resolution images
###        + a list for predictors
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
### read LR/HR image pairs
for(i in 1:1){
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
### step 1. sample n_points from imgLR
dimLR <- dim(imgLR)
pixels = seq(1,dimLR[1] * dimLR[2])
pixels_row <- (pixels - 1)%%dimLR[1] + 1
pixels_col <- (pixels - 1)%/%dimLR[1] + 1
### step 2. for each sampled point in imgLR
### step 2.1. save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
n_points <- dim(imgLR)[1] * dim(imgLR)[2]
for(j in 1:3){
pad <- cbind(0, imgLR[,,j], 0)
pad <- rbind(0, pad, 0)
featMat[1:n_points, 1, j] <- pad[cbind(pixels_row, pixels_col)]
featMat[1:n_points, 2, j] <- pad[cbind(pixels_row, pixels_col + 1)]
featMat[1:n_points, 3, j] <- pad[cbind(pixels_row, pixels_col+2)]
featMat[1:n_points, 4, j] <- pad[cbind(pixels_row +1, pixels_col+2)]
featMat[1:n_points, 5, j] <- pad[cbind(pixels_row +2, pixels_col+2)]
featMat[1:n_points, 6, j] <- pad[cbind(pixels_row+2, pixels_col+1)]
featMat[1:n_points, 7, j] <- pad[cbind(pixels_row+2, pixels_col)]
featMat[1:n_points, 8, j] <- pad[cbind(pixels_row+1, pixels_col)]
}
### step 2. apply the modelList over featMat
predMat <- test(modelList, featMat)$arraypred
### step 3. recover high-resolution from predMat and save in HR_dir
#imagearray <- array(NA, c((dim(imgLR)[1]*2) * (dim(imgLR)[2]*2), 8, 3))
#for(k in 1:3){
#imagearray[,,k] <-
#}
writeImage(predMat , file = paste(HR_dir, i, ".jpg", sep = ""))
}
}
#source("../lib/superResolution.R")
test_dir <- "../data/test_sample/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(LR_dir=test_LR_dir, HR_dir=test_HR_dir, modelList=fit_train))
}
dim(predMat)
dimLR
61060/320
cbind(select_row, select_col)
a <- array(seq(1:18),NA, c(2, 3, 3))
a <- array(seq(1:18), c(2, 3, 3))
a
m <- cbind(select_row, select_col)[1,]
m
a[m]
m <- cbind(c(1,1),c(2,2))
m
a[m]
m <- cbind(c(1,2),c(3,4))
a[m]
m
a[m]
